import { StringWrapper, BaseException, isPresent, isBlank, isString, stringify } from 'angular2/src/facade/lang';
import { ListWrapper, StringMapWrapper } from 'angular2/src/facade/collection';
import { DOM } from 'angular2/src/dom/dom_adapter';
import { camelCaseToDashCase } from '../util';
import { reflector } from 'angular2/src/reflection/reflection';
const STYLE_SEPARATOR = '.';
const ATTRIBUTE_PREFIX = 'attr.';
const CLASS_PREFIX = 'class.';
const STYLE_PREFIX = 'style.';
export class PropertySetterFactory {
    constructor() {
        this._lazyPropertySettersCache = StringMapWrapper.create();
        this._eagerPropertySettersCache = StringMapWrapper.create();
        this._innerHTMLSetterCache = (el, value) => DOM.setInnerHTML(el, value);
        this._attributeSettersCache = StringMapWrapper.create();
        this._classSettersCache = StringMapWrapper.create();
        this._styleSettersCache = StringMapWrapper.create();
    }
    static _noopSetter(el, value) { }
    createSetter(protoElement, isNgComponent, property) {
        var setterFn, styleParts, styleSuffix;
        if (StringWrapper.startsWith(property, ATTRIBUTE_PREFIX)) {
            setterFn =
                this._attributeSetterFactory(StringWrapper.substring(property, ATTRIBUTE_PREFIX.length));
        }
        else if (StringWrapper.startsWith(property, CLASS_PREFIX)) {
            setterFn = this._classSetterFactory(StringWrapper.substring(property, CLASS_PREFIX.length));
        }
        else if (StringWrapper.startsWith(property, STYLE_PREFIX)) {
            styleParts = property.split(STYLE_SEPARATOR);
            styleSuffix = styleParts.length > 2 ? ListWrapper.get(styleParts, 2) : '';
            setterFn = this._styleSetterFactory(ListWrapper.get(styleParts, 1), styleSuffix);
        }
        else if (StringWrapper.equals(property, 'innerHtml')) {
            setterFn = this._innerHTMLSetterCache;
        }
        else {
            property = this._resolvePropertyName(property);
            setterFn = this._propertySetterFactory(protoElement, isNgComponent, property);
        }
        return setterFn;
    }
    _propertySetterFactory(protoElement, isNgComponent, property) {
        var setterFn;
        var tagName = DOM.tagName(protoElement);
        var possibleCustomElement = tagName.indexOf('-') !== -1;
        if (possibleCustomElement && !isNgComponent) {
            // need to use late check to be able to set properties on custom elements
            setterFn = StringMapWrapper.get(this._lazyPropertySettersCache, property);
            if (isBlank(setterFn)) {
                var propertySetterFn = reflector.setter(property);
                setterFn = (receiver, value) => {
                    if (DOM.hasProperty(receiver, property)) {
                        return propertySetterFn(receiver, value);
                    }
                };
                StringMapWrapper.set(this._lazyPropertySettersCache, property, setterFn);
            }
        }
        else {
            setterFn = StringMapWrapper.get(this._eagerPropertySettersCache, property);
            if (isBlank(setterFn)) {
                if (DOM.hasProperty(protoElement, property)) {
                    setterFn = reflector.setter(property);
                }
                else {
                    setterFn = PropertySetterFactory._noopSetter;
                }
                StringMapWrapper.set(this._eagerPropertySettersCache, property, setterFn);
            }
        }
        return setterFn;
    }
    _isValidAttributeValue(attrName, value) {
        if (attrName == "role") {
            return isString(value);
        }
        else {
            return isPresent(value);
        }
    }
    _attributeSetterFactory(attrName) {
        var setterFn = StringMapWrapper.get(this._attributeSettersCache, attrName);
        var dashCasedAttributeName;
        if (isBlank(setterFn)) {
            dashCasedAttributeName = camelCaseToDashCase(attrName);
            setterFn = (element, value) => {
                if (this._isValidAttributeValue(dashCasedAttributeName, value)) {
                    DOM.setAttribute(element, dashCasedAttributeName, stringify(value));
                }
                else {
                    if (isPresent(value)) {
                        throw new BaseException("Invalid " + dashCasedAttributeName +
                            " attribute, only string values are allowed, got '" +
                            stringify(value) + "'");
                    }
                    DOM.removeAttribute(element, dashCasedAttributeName);
                }
            };
            StringMapWrapper.set(this._attributeSettersCache, attrName, setterFn);
        }
        return setterFn;
    }
    _classSetterFactory(className) {
        var setterFn = StringMapWrapper.get(this._classSettersCache, className);
        var dashCasedClassName;
        if (isBlank(setterFn)) {
            dashCasedClassName = camelCaseToDashCase(className);
            setterFn = (element, isAdd) => {
                if (isAdd) {
                    DOM.addClass(element, dashCasedClassName);
                }
                else {
                    DOM.removeClass(element, dashCasedClassName);
                }
            };
            StringMapWrapper.set(this._classSettersCache, className, setterFn);
        }
        return setterFn;
    }
    _styleSetterFactory(styleName, styleSuffix) {
        var cacheKey = styleName + styleSuffix;
        var setterFn = StringMapWrapper.get(this._styleSettersCache, cacheKey);
        var dashCasedStyleName;
        if (isBlank(setterFn)) {
            dashCasedStyleName = camelCaseToDashCase(styleName);
            setterFn = (element, value) => {
                var valAsStr;
                if (isPresent(value)) {
                    valAsStr = stringify(value);
                    DOM.setStyle(element, dashCasedStyleName, valAsStr + styleSuffix);
                }
                else {
                    DOM.removeStyle(element, dashCasedStyleName);
                }
            };
            StringMapWrapper.set(this._styleSettersCache, cacheKey, setterFn);
        }
        return setterFn;
    }
    _resolvePropertyName(attrName) {
        var mappedPropName = StringMapWrapper.get(DOM.attrToPropMap, attrName);
        return isPresent(mappedPropName) ? mappedPropName : attrName;
    }
}
//# sourceMappingURL=property_setter_factory.js.map