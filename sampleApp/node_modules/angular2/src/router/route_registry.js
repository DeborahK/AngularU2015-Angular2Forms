var route_recognizer_1 = require('./route_recognizer');
var instruction_1 = require('./instruction');
var collection_1 = require('angular2/src/facade/collection');
var async_1 = require('angular2/src/facade/async');
var lang_1 = require('angular2/src/facade/lang');
var route_config_impl_1 = require('./route_config_impl');
var reflection_1 = require('angular2/src/reflection/reflection');
/**
 * The RouteRegistry holds route configurations for each component in an Angular app.
 * It is responsible for creating Instructions from URLs, and generating URLs based on route and
 * parameters.
 */
var RouteRegistry = (function () {
    function RouteRegistry() {
        this._rules = collection_1.MapWrapper.create();
    }
    /**
     * Given a component and a configuration object, add the route to this registry
     */
    RouteRegistry.prototype.config = function (parentComponent, config) {
        assertValidConfig(config);
        var recognizer = collection_1.MapWrapper.get(this._rules, parentComponent);
        if (lang_1.isBlank(recognizer)) {
            recognizer = new route_recognizer_1.RouteRecognizer();
            collection_1.MapWrapper.set(this._rules, parentComponent, recognizer);
        }
        if (collection_1.StringMapWrapper.contains(config, 'redirectTo')) {
            recognizer.addRedirect(config['path'], config['redirectTo']);
            return;
        }
        config = collection_1.StringMapWrapper.merge(config, { 'component': normalizeComponentDeclaration(config['component']) });
        var component = config['component'];
        this.configFromComponent(component);
        recognizer.addConfig(config['path'], config, config['as']);
    };
    /**
     * Reads the annotations of a component and configures the registry based on them
     */
    RouteRegistry.prototype.configFromComponent = function (component) {
        var _this = this;
        if (!lang_1.isType(component)) {
            return;
        }
        // Don't read the annotations from a type more than once â€“
        // this prevents an infinite loop if a component routes recursively.
        if (collection_1.MapWrapper.contains(this._rules, component)) {
            return;
        }
        var annotations = reflection_1.reflector.annotations(component);
        if (lang_1.isPresent(annotations)) {
            for (var i = 0; i < annotations.length; i++) {
                var annotation = annotations[i];
                if (annotation instanceof route_config_impl_1.RouteConfig) {
                    collection_1.ListWrapper.forEach(annotation.configs, function (config) { return _this.config(component, config); });
                }
            }
        }
    };
    /**
     * Given a URL and a parent component, return the most specific instruction for navigating
     * the application into the state specified by the
     */
    RouteRegistry.prototype.recognize = function (url, parentComponent) {
        var _this = this;
        var componentRecognizer = collection_1.MapWrapper.get(this._rules, parentComponent);
        if (lang_1.isBlank(componentRecognizer)) {
            return async_1.PromiseWrapper.resolve(null);
        }
        // Matches some beginning part of the given URL
        var possibleMatches = componentRecognizer.recognize(url);
        var matchPromises = collection_1.ListWrapper.map(possibleMatches, function (candidate) { return _this._completeRouteMatch(candidate); });
        return async_1.PromiseWrapper.all(matchPromises)
            .then(function (solutions) {
            // remove nulls
            var fullSolutions = collection_1.ListWrapper.filter(solutions, function (solution) { return lang_1.isPresent(solution); });
            if (fullSolutions.length > 0) {
                return mostSpecific(fullSolutions);
            }
            return null;
        });
    };
    RouteRegistry.prototype._completeRouteMatch = function (candidate) {
        var _this = this;
        return componentHandlerToComponentType(candidate.handler)
            .then(function (componentType) {
            _this.configFromComponent(componentType);
            if (candidate.unmatchedUrl.length == 0) {
                return new instruction_1.Instruction({
                    component: componentType,
                    params: candidate.params,
                    matchedUrl: candidate.matchedUrl,
                    parentSpecificity: candidate.specificity
                });
            }
            return _this.recognize(candidate.unmatchedUrl, componentType)
                .then(function (childInstruction) {
                if (lang_1.isBlank(childInstruction)) {
                    return null;
                }
                return new instruction_1.Instruction({
                    component: componentType,
                    child: childInstruction,
                    params: candidate.params,
                    matchedUrl: candidate.matchedUrl,
                    parentSpecificity: candidate.specificity
                });
            });
        });
    };
    RouteRegistry.prototype.generate = function (name, params, hostComponent) {
        // TODO: implement for hierarchical routes
        var componentRecognizer = collection_1.MapWrapper.get(this._rules, hostComponent);
        return lang_1.isPresent(componentRecognizer) ? componentRecognizer.generate(name, params) : null;
    };
    return RouteRegistry;
})();
exports.RouteRegistry = RouteRegistry;
/*
 * A config should have a "path" property, and exactly one of:
 * - `component`
 * - `redirectTo`
 */
var ALLOWED_TARGETS = ['component', 'redirectTo'];
function assertValidConfig(config) {
    if (!collection_1.StringMapWrapper.contains(config, 'path')) {
        throw new lang_1.BaseException("Route config should contain a \"path\" property");
    }
    var targets = 0;
    collection_1.ListWrapper.forEach(ALLOWED_TARGETS, function (target) {
        if (collection_1.StringMapWrapper.contains(config, target)) {
            targets += 1;
        }
    });
    if (targets != 1) {
        throw new lang_1.BaseException("Route config should contain exactly one 'component', or 'redirectTo' property");
    }
}
/*
 * Returns a StringMap like: `{ 'constructor': SomeType, 'type': 'constructor' }`
 */
var VALID_COMPONENT_TYPES = ['constructor', 'loader'];
function normalizeComponentDeclaration(config) {
    if (lang_1.isType(config)) {
        return { 'constructor': config, 'type': 'constructor' };
    }
    else if (lang_1.isStringMap(config)) {
        if (lang_1.isBlank(config['type'])) {
            throw new lang_1.BaseException("Component declaration when provided as a map should include a 'type' property");
        }
        var componentType = config['type'];
        if (!collection_1.ListWrapper.contains(VALID_COMPONENT_TYPES, componentType)) {
            throw new lang_1.BaseException("Invalid component type '" + componentType + "'");
        }
        return config;
    }
    else {
        throw new lang_1.BaseException("Component declaration should be either a Map or a Type");
    }
}
function componentHandlerToComponentType(handler) {
    var componentDeclaration = handler['component'], type = componentDeclaration['type'];
    if (type == 'constructor') {
        return async_1.PromiseWrapper.resolve(componentDeclaration['constructor']);
    }
    else if (type == 'loader') {
        var resolverFunction = componentDeclaration['loader'];
        return resolverFunction();
    }
    else {
        throw new lang_1.BaseException("Cannot extract the component type from a '" + type + "' component");
    }
}
/*
 * Given a list of instructions, returns the most specific instruction
 */
function mostSpecific(instructions) {
    var mostSpecificSolution = instructions[0];
    for (var solutionIndex = 1; solutionIndex < instructions.length; solutionIndex++) {
        var solution = instructions[solutionIndex];
        if (solution.specificity > mostSpecificSolution.specificity) {
            mostSpecificSolution = solution;
        }
    }
    return mostSpecificSolution;
}
exports.__esModule = true;
//# sourceMappingURL=route_registry.js.map